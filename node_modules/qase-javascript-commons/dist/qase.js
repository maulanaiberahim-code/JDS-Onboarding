"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QaseReporter = void 0;
const child_process_1 = require("child_process");
const env_schema_1 = __importDefault(require("env-schema"));
const chalk_1 = __importDefault(require("chalk"));
const qaseio_1 = require("qaseio");
const reporters_1 = require("./reporters");
const options_1 = require("./options");
const env_1 = require("./env");
const models_1 = require("./models");
const writer_1 = require("./writer");
const get_package_version_1 = require("./utils/get-package-version");
const custom_boundary_1 = require("./utils/custom-boundary");
const disabled_exception_1 = require("./utils/disabled-exception");
const logger_1 = require("./utils/logger");
const state_1 = require("./state/state");
/**
 * @type {Record<TestStatusEnum, (test: TestResultType) => string>}
 */
const resultLogMap = {
    [models_1.TestStatusEnum.failed]: (test) => (0, chalk_1.default) `{red Test ${test.title} ${test.execution.status}}`,
    [models_1.TestStatusEnum.passed]: (test) => (0, chalk_1.default) `{green Test ${test.title} ${test.execution.status}}`,
    [models_1.TestStatusEnum.skipped]: (test) => (0, chalk_1.default) `{blueBright Test ${test.title} ${test.execution.status}}`,
    [models_1.TestStatusEnum.blocked]: (test) => (0, chalk_1.default) `{blueBright Test ${test.title} ${test.execution.status}}`,
    [models_1.TestStatusEnum.disabled]: (test) => (0, chalk_1.default) `{grey Test ${test.title} ${test.execution.status}}`,
    [models_1.TestStatusEnum.invalid]: (test) => (0, chalk_1.default) `{yellowBright Test ${test.title} ${test.execution.status}}`,
};
/**
 * @class QaseReporter
 * @implements AbstractReporter
 */
class QaseReporter {
    /**
     * @param {string} frameworkPackage
     * @param {string} frameworkName
     * @param {string} reporterName
     * @returns {Record<string, string>}
     * @private
     */
    static createHeaders(frameworkPackage, frameworkName, reporterName) {
        const { version: nodeVersion, platform: os, arch } = process;
        const npmVersion = (0, child_process_1.execSync)('npm -v', { encoding: 'utf8' }).replace(/['"\n]+/g, '');
        const qaseApiVersion = (0, get_package_version_1.getPackageVersion)('qaseio');
        const qaseReporterVersion = (0, get_package_version_1.getPackageVersion)('qase-javascript-commons');
        const frameworkVersion = (0, get_package_version_1.getPackageVersion)(frameworkPackage);
        const reporterVersion = (0, get_package_version_1.getPackageVersion)(reporterName);
        const client = [];
        if (frameworkVersion) {
            client.push(`${frameworkName}=${frameworkVersion}`);
        }
        if (reporterVersion) {
            client.push(`qase-${frameworkName}=${reporterVersion}`);
        }
        if (qaseReporterVersion) {
            client.push(`qase-core-reporter=${qaseReporterVersion}`);
        }
        if (qaseApiVersion) {
            client.push(`qaseio=${String(qaseApiVersion)}`);
        }
        return {
            'X-Client': client.join('; '),
            'X-Platform': `node=${nodeVersion}; npm=${npmVersion}; os=${os}; arch=${arch}`,
        };
    }
    /**
     * @param {OptionsType} options
     */
    constructor(options) {
        /**
         * @type {boolean}
         * @private
         */
        this.disabled = false;
        /**
         * @type {boolean}
         * @private
         */
        this.useFallback = false;
        if (state_1.StateManager.isStateExists()) {
            const state = state_1.StateManager.getState();
            if (state.IsModeChanged && state.Mode) {
                process.env[env_1.EnvEnum.mode] = state.Mode.toString();
            }
            if (state.RunId) {
                process.env[env_1.EnvRunEnum.id] = state.RunId.toString();
            }
        }
        const env = (0, env_1.envToConfig)((0, env_schema_1.default)({ schema: env_1.envValidationSchema }));
        const composedOptions = (0, options_1.composeOptions)(options, env);
        this.options = composedOptions;
        this.logger = new logger_1.Logger({ debug: composedOptions.debug });
        this.logger.logDebug(`Config: ${JSON.stringify(composedOptions)}`);
        this.captureLogs = composedOptions.captureLogs;
        try {
            this.upstreamReporter = this.createReporter(
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            composedOptions.mode || options_1.ModeEnum.off, composedOptions);
        }
        catch (error) {
            if (error instanceof disabled_exception_1.DisabledException) {
                this.disabled = true;
            }
            else {
                this.logger.logError('Unable to create upstream reporter:', error);
                if (composedOptions.fallback != undefined) {
                    this.disabled = true;
                    return;
                }
                this.useFallback = true;
            }
        }
        try {
            this.fallbackReporter = this.createReporter(
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            composedOptions.fallback || options_1.ModeEnum.off, composedOptions);
        }
        catch (error) {
            if (error instanceof disabled_exception_1.DisabledException) {
                if (this.useFallback) {
                    this.disabled = true;
                }
            }
            else {
                this.logger.logError('Unable to create fallback reporter:', error);
                if (this.useFallback && this.upstreamReporter === undefined) {
                    this.disabled = true;
                }
            }
        }
        if (!state_1.StateManager.isStateExists()) {
            const state = {
                RunId: undefined,
                Mode: this.useFallback ? composedOptions.fallback : composedOptions.mode,
                IsModeChanged: undefined,
            };
            if (this.disabled) {
                state.Mode = options_1.ModeEnum.off;
            }
            state_1.StateManager.setState(state);
        }
    }
    getResults() {
        if (this.disabled) {
            return [];
        }
        if (this.useFallback) {
            return this.fallbackReporter?.getTestResults() ?? [];
        }
        return this.upstreamReporter?.getTestResults() ?? [];
    }
    setTestResults(results) {
        if (this.disabled) {
            return;
        }
        if (this.useFallback) {
            this.fallbackReporter?.setTestResults(results);
        }
        else {
            this.upstreamReporter?.setTestResults(results);
        }
    }
    async sendResults() {
        if (this.disabled) {
            return;
        }
        try {
            await this.upstreamReporter?.sendResults();
        }
        catch (error) {
            this.logger.logError('Unable to send the results to the upstream reporter:', error);
            if (this.fallbackReporter == undefined) {
                state_1.StateManager.setMode(options_1.ModeEnum.off);
                return;
            }
            if (!this.useFallback) {
                this.fallbackReporter.setTestResults(this.upstreamReporter?.getTestResults() ?? []);
                this.useFallback = true;
            }
            try {
                await this.fallbackReporter?.sendResults();
                state_1.StateManager.setMode(this.options.fallback);
            }
            catch (error) {
                this.logger.logError('Unable to send the results to the fallback reporter:', error);
                state_1.StateManager.setMode(options_1.ModeEnum.off);
            }
        }
    }
    async complete() {
        state_1.StateManager.clearState();
        if (this.disabled) {
            return;
        }
        try {
            await this.upstreamReporter?.complete();
        }
        catch (error) {
            this.logger.logError('Unable to complete the run in the upstream reporter:', error);
            if (this.fallbackReporter == undefined) {
                return;
            }
            if (!this.useFallback) {
                this.fallbackReporter.setTestResults(this.upstreamReporter?.getTestResults() ?? []);
                this.useFallback = true;
            }
            try {
                await this.fallbackReporter?.complete();
            }
            catch (error) {
                this.logger.logError('Unable to complete the run in the fallback reporter:', error);
            }
        }
    }
    /**
     * @returns {void}
     */
    startTestRun() {
        if (!this.disabled) {
            this.logger.logDebug('Starting test run');
            try {
                this.startTestRunOperation = this.upstreamReporter?.startTestRun();
            }
            catch (error) {
                this.logger.logError('Unable to start test run in the upstream reporter: ', error);
                if (this.fallbackReporter == undefined) {
                    this.disabled = true;
                    state_1.StateManager.setMode(options_1.ModeEnum.off);
                    return;
                }
                try {
                    this.startTestRunOperation = this.fallbackReporter?.startTestRun();
                    state_1.StateManager.setMode(this.options.fallback);
                }
                catch (error) {
                    this.logger.logError('Unable to start test run in the fallback reporter: ', error);
                    this.disabled = true;
                    state_1.StateManager.setMode(options_1.ModeEnum.off);
                }
            }
        }
    }
    async startTestRunAsync() {
        this.startTestRun();
        await this.startTestRunOperation;
    }
    /**
     * @param {OptionsType} options
     * @returns {QaseReporter}
     */
    static getInstance(options) {
        if (!QaseReporter.instance) {
            QaseReporter.instance = new QaseReporter(options);
        }
        return QaseReporter.instance;
    }
    /**
     * @param {TestResultType} result
     */
    async addTestResult(result) {
        if (!this.disabled) {
            await this.startTestRunOperation;
            this.logTestItem(result);
            if (this.useFallback) {
                await this.addTestResultToFallback(result);
                return;
            }
            try {
                await this.upstreamReporter?.addTestResult(result);
            }
            catch (error) {
                this.logger.logError('Unable to add the result to the upstream reporter:', error);
                if (this.fallbackReporter == undefined) {
                    this.disabled = true;
                    state_1.StateManager.setMode(options_1.ModeEnum.off);
                    return;
                }
                if (!this.useFallback) {
                    this.fallbackReporter.setTestResults(this.upstreamReporter?.getTestResults() ?? []);
                    this.useFallback = true;
                }
                await this.addTestResultToFallback(result);
            }
        }
    }
    /**
     * @param {TestResultType} result
     * @private
     */
    async addTestResultToFallback(result) {
        try {
            await this.fallbackReporter?.addTestResult(result);
            state_1.StateManager.setMode(this.options.fallback);
        }
        catch (error) {
            this.logger.logError('Unable to add the result to the fallback reporter:', error);
            this.disabled = true;
            state_1.StateManager.setMode(options_1.ModeEnum.off);
        }
    }
    /**
     * @returns {boolean}
     */
    isCaptureLogs() {
        return this.captureLogs ?? false;
    }
    /**
     * @returns {Promise<void>}
     */
    async publish() {
        if (!this.disabled) {
            await this.startTestRunOperation;
            this.logger.logDebug('Publishing test run results');
            if (this.useFallback) {
                await this.publishFallback();
            }
            try {
                await this.upstreamReporter?.publish();
            }
            catch (error) {
                this.logger.logError('Unable to publish the run results to the upstream reporter:', error);
                if (this.fallbackReporter == undefined) {
                    this.disabled = true;
                    state_1.StateManager.setMode(options_1.ModeEnum.off);
                    return;
                }
                if (!this.useFallback) {
                    this.fallbackReporter.setTestResults(this.upstreamReporter?.getTestResults() ?? []);
                    this.useFallback = true;
                }
                await this.publishFallback();
            }
        }
        state_1.StateManager.clearState();
    }
    /**
     * @returns {Promise<void>}
     */
    async publishFallback() {
        try {
            await this.fallbackReporter?.publish();
            state_1.StateManager.setMode(this.options.fallback);
        }
        catch (error) {
            state_1.StateManager.setMode(options_1.ModeEnum.off);
            this.logger.logError('Unable to publish the run results to the fallback reporter:', error);
            this.disabled = true;
        }
    }
    /**
     * @todo implement mode registry
     * @param {ModeEnum} mode
     * @param {OptionsType} options
     * @returns {InternalReporterInterface}
     * @private
     */
    createReporter(mode, options) {
        const { frameworkPackage, frameworkName, reporterName, environment, rootSuite, report = {}, testops = {}, } = options;
        switch (mode) {
            case options_1.ModeEnum.testops: {
                const { api: { token, headers, ...api } = {}, project, run: { title, description, ...run } = {}, plan = {}, batch = {}, useV2, defect, uploadAttachments, } = testops;
                if (!token) {
                    throw new Error(`Either "testops.api.token" parameter or "${env_1.EnvApiEnum.token}" environment variable is required in "testops" mode`);
                }
                if (!project) {
                    throw new Error(`Either "testops.project" parameter or "${env_1.EnvTestOpsEnum.project}" environment variable is required in "testops" mode`);
                }
                const apiClient = new qaseio_1.QaseApi({
                    token,
                    headers: {
                        ...headers,
                        ...QaseReporter.createHeaders(frameworkPackage, frameworkName, reporterName),
                    },
                    ...api,
                }, custom_boundary_1.CustomBoundaryFormData);
                return new reporters_1.TestOpsReporter(this.logger, {
                    project,
                    uploadAttachments,
                    run: {
                        title: title ?? `Automated run ${new Date().toISOString()}`,
                        description: description ?? `${reporterName} automated run`,
                        ...run,
                    },
                    plan,
                    batch,
                    useV2,
                    defect,
                }, apiClient, environment, rootSuite, api.host);
            }
            case options_1.ModeEnum.report: {
                const localOptions = report.connections?.[writer_1.DriverEnum.local];
                const writer = new writer_1.FsWriter(localOptions);
                return new reporters_1.ReportReporter(this.logger, writer, environment, rootSuite, testops.run?.id);
            }
            case options_1.ModeEnum.off:
                throw new disabled_exception_1.DisabledException();
            default:
                throw new Error(`Unknown mode type`);
        }
    }
    /**
     * @param {TestResultType} test
     * @private
     */
    logTestItem(test) {
        this.logger.log(resultLogMap[test.execution.status](test));
    }
}
exports.QaseReporter = QaseReporter;
