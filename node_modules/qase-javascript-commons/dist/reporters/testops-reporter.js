"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestOpsReporter = void 0;
const fs_1 = require("fs");
const chalk_1 = __importDefault(require("chalk"));
const qaseio_1 = require("qaseio");
const abstract_reporter_1 = require("./abstract-reporter");
const models_1 = require("../models");
const qase_error_1 = require("../utils/qase-error");
const axios_1 = __importDefault(require("axios"));
const state_1 = require("../state/state");
const defaultChunkSize = 200;
/**
 * @class TestOpsReporter
 * @extends AbstractReporter
 */
class TestOpsReporter extends abstract_reporter_1.AbstractReporter {
    /**
     * @param {LoggerInterface} logger
     * @param {ReporterOptionsType & TestOpsOptionsType} options
     * @param {QaseApiInterface} api
     * @param {string | undefined} environment
     * @param {string | undefined} rootSuite
     * @param {string | undefined} baseUrl
     */
    constructor(logger, options, api, environment, rootSuite, baseUrl) {
        const { project, uploadAttachments, run, plan, } = options;
        super(logger);
        this.api = api;
        /**
         * @type {number}
         * @private
         */
        this.firstIndex = 0;
        /**
         * @type {boolean}
         * @private
         */
        this.isTestRunReady = false;
        this.baseUrl = this.getBaseUrl(baseUrl);
        this.projectCode = project;
        this.isUploadAttachments = uploadAttachments;
        this.run = { complete: true, ...run };
        this.environment = environment;
        this.planId = plan.id;
        this.batchSize = options.batch?.size ?? defaultChunkSize;
        this.useV2 = options.useV2 ?? false;
        this.defect = options.defect ?? false;
        this.rootSuite = rootSuite;
    }
    /**
     * @returns {Promise<void>}
     */
    async startTestRun() {
        await this.checkOrCreateTestRun();
    }
    /**
     * @param {TestResultType} result
     * @returns {Promise<void>}
     */
    async addTestResult(result) {
        if (result.execution.status === models_1.TestStatusEnum.failed) {
            const testOpsIds = Array.isArray(result.testops_id) ? result.testops_id : [result.testops_id];
            for (const id of testOpsIds) {
                this.showLink(id, result.title);
            }
        }
        await super.addTestResult(result);
        if (!this.isTestRunReady) {
            return;
        }
        const countOfResults = this.batchSize + this.firstIndex;
        if (this.results.length >= countOfResults) {
            const firstIndex = this.firstIndex;
            this.firstIndex = countOfResults;
            await this.publishResults(this.results.slice(firstIndex, countOfResults));
        }
    }
    /**
     * @returns {Promise<void>}
     */
    async checkOrCreateTestRun() {
        if (this.run.id !== undefined) {
            this.isTestRunReady = true;
            return;
        }
        this.logger.logDebug('Creating test run');
        let environmentId;
        if (this.environment != undefined) {
            try {
                const { data } = await this.api.environment.getEnvironments(this.projectCode, undefined, this.environment, 100);
                const env = data.result?.entities?.find((env) => env.slug === this.environment);
                if (env) {
                    environmentId = env.id;
                }
            }
            catch (error) {
                throw this.processError(error, 'Error on getting environments');
            }
        }
        const { result } = await this.createRun(this.run.title, this.run.description, environmentId);
        if (!result?.id) {
            throw new Error('Cannot create run.');
        }
        this.logger.logDebug(`Test run created: ${result.id}`);
        this.run.id = result.id;
        process.env['QASE_TESTOPS_RUN_ID'] = String(result.id);
        state_1.StateManager.setRunId(result.id);
        this.isTestRunReady = true;
    }
    /**
     * @returns {Promise<void>}
     * @param testResults
     * @private
     */
    async publishResults(testResults) {
        if (this.useV2) {
            const results = [];
            for (const result of testResults) {
                const resultCreateV2 = await this.transformTestResult(result);
                results.push(resultCreateV2);
            }
            try {
                await this.api.result.createResultsV2(this.projectCode, this.run.id, {
                    results: results,
                });
            }
            catch (error) {
                throw this.processError(error, 'Error on uploading results', results);
            }
        }
        else {
            const results = [];
            for (const result of testResults) {
                const resultCreate = await this.transformTestResultV1(result);
                results.push(resultCreate);
            }
            try {
                await this.api.results.createResultBulk(this.projectCode, this.run.id, {
                    results: results,
                });
            }
            catch (error) {
                throw this.processError(error, 'Error on uploading results', results);
            }
        }
        this.logger.logDebug(`Results sent to Qase: ${testResults.length}`);
    }
    /**
     * @returns {Promise<void>}
     */
    async publish() {
        await this.sendResults();
        await this.complete();
    }
    /**
     * @returns {Promise<void>}
     */
    async sendResults() {
        if (this.results.length === 0) {
            this.logger.log((0, chalk_1.default) `{yellow No results to send to Qase}`);
            return;
        }
        const remainingResults = this.results.slice(this.firstIndex);
        if (this.firstIndex < this.results.length) {
            if (remainingResults.length <= defaultChunkSize) {
                await this.publishResults(remainingResults);
                return;
            }
            for (let i = 0; i < remainingResults.length; i += defaultChunkSize) {
                await this.publishResults(remainingResults.slice(i, i + defaultChunkSize));
            }
        }
        // Clear results because we don't need to send them again then we use Cypress reporter
        this.results.length = 0;
    }
    /**
     * @returns {Promise<void>}
     */
    async complete() {
        if (!this.run.complete) {
            return;
        }
        try {
            await this.api.runs.completeRun(this.projectCode, this.run.id);
            this.logger.log((0, chalk_1.default) `{green Run ${this.run.id} completed}`);
        }
        catch (error) {
            throw this.processError(error, 'Error on completing run');
        }
        const runUrl = `${this.baseUrl}/run/${this.projectCode}/dashboard/${this.run.id}`;
        this.logger.log((0, chalk_1.default) `{blue Test run link: ${runUrl}}`);
    }
    /**
     * @param {TestResultType} result
     * @returns Promise<ResultCreateV2>
     * @private
     */
    async transformTestResult(result) {
        const attachments = await this.uploadAttachments(result.attachments);
        const steps = await this.transformSteps(result.steps, result.title);
        const param = {};
        for (const key in result.params) {
            const value = result.params[key];
            if (!value) {
                continue;
            }
            param[key] = value;
        }
        const group_params = [];
        const keys = Object.keys(result.group_params);
        if (keys.length > 0) {
            group_params.push(keys);
        }
        for (const key in result.group_params) {
            const value = result.group_params[key];
            if (!value) {
                continue;
            }
            param[key] = value;
        }
        const model = {
            title: result.title,
            execution: this.getExecution(result.execution),
            testops_id: Array.isArray(result.testops_id) ? null : result.testops_id,
            attachments: attachments,
            steps: steps,
            params: param,
            param_groups: group_params,
            relations: this.getRelation(result.relations),
            message: result.message,
            fields: result.fields,
        };
        this.logger.logDebug(`Transformed result: ${JSON.stringify(model)}`);
        return model;
    }
    /**
     * @param {TestResultType} result
     * @returns Promise<ResultCreate>
     * @private
     */
    async transformTestResultV1(result) {
        const attachments = await this.uploadAttachments(result.attachments);
        const steps = await this.transformStepsV1(result.steps, result.title);
        const param = {};
        for (const key in result.params) {
            const value = result.params[key];
            if (!value) {
                continue;
            }
            param[key] = value;
        }
        const group_params = [];
        const keys = Object.keys(result.group_params);
        if (keys.length > 0) {
            group_params.push(keys);
        }
        for (const key in result.group_params) {
            const value = result.group_params[key];
            if (!value) {
                continue;
            }
            param[key] = value;
        }
        const resultCreate = {
            attachments: attachments,
            comment: result.message,
            defect: this.defect,
            param: param,
            param_groups: group_params,
            stacktrace: result.execution.stacktrace,
            start_time: result.execution.start_time ? result.execution.start_time | 0 : null,
            status: result.execution.status,
            steps: steps,
            time: result.execution.end_time,
            time_ms: result.execution.duration,
        };
        const id = Array.isArray(result.testops_id) ? null : result.testops_id;
        if (id) {
            resultCreate.case_id = id;
        }
        const rootSuite = this.rootSuite ? `${this.rootSuite}\t` : '';
        resultCreate.case = {
            title: result.title,
            suite_title: result.relations?.suite ? `${rootSuite}${result.relations.suite.data.map((suite) => suite.title).join('\t')}` : rootSuite,
            description: result.fields['description'] ?? null,
            postconditions: result.fields['postconditions'] ?? null,
            preconditions: result.fields['preconditions'] ?? null,
        };
        if (result.fields['severity']) {
            resultCreate.case.severity = result.fields['severity'];
        }
        if (result.fields['priority']) {
            resultCreate.case.priority = result.fields['priority'];
        }
        if (result.fields['layer']) {
            resultCreate.case.layer = result.fields['layer'];
        }
        if (result.fields['author']) {
            const resp = await this.api.authors.getAuthors(result.fields['author']);
            if (resp.data.result?.entities && resp.data.result.entities.length > 0) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                resultCreate.author_id = resp.data.result.entities[0]?.author_id ?? null;
            }
        }
        this.logger.logDebug(`Transformed result: ${JSON.stringify(resultCreate)}`);
        return resultCreate;
    }
    /**
     * @returns {ResultExecution}
     * @private
     * @param {TestExecution} exec
     */
    getExecution(exec) {
        return {
            status: TestOpsReporter.statusMap[exec.status],
            start_time: exec.start_time,
            end_time: exec.end_time,
            duration: exec.duration,
            stacktrace: exec.stacktrace,
            thread: exec.thread,
        };
    }
    /**
     * @param {Relation | null} relation
     * @returns {ResultRelations}
     * @private
     */
    getRelation(relation) {
        if (!relation?.suite) {
            if (this.rootSuite == undefined) {
                return {};
            }
            return {
                suite: {
                    data: [
                        {
                            public_id: null,
                            title: this.rootSuite,
                        },
                    ],
                },
            };
        }
        const suiteData = [];
        if (this.rootSuite != undefined) {
            suiteData.push({
                public_id: null,
                title: this.rootSuite,
            });
        }
        for (const data of relation.suite.data) {
            suiteData.push({
                public_id: null,
                title: data.title,
            });
        }
        return {
            suite: {
                data: suiteData,
            },
        };
    }
    /**
     * @param {TestStepType[]} steps
     * @param testTitle
     * @returns Promise<ResultStep[]>
     * @private
     */
    async transformSteps(steps, testTitle) {
        const resultsSteps = [];
        for (const step of steps) {
            const attachmentHashes = await this.uploadAttachments(step.attachments);
            const resultStep = {
                data: {
                    action: '',
                },
                execution: {
                    status: TestOpsReporter.stepStatusMap[step.execution.status],
                    attachments: attachmentHashes,
                },
            };
            if (step.step_type === models_1.StepType.TEXT) {
                if ('action' in step.data && resultStep.data != undefined) {
                    if (step.data.action === '') {
                        this.logEmptyStep(testTitle);
                        resultStep.data.action = 'Unnamed step';
                    }
                    else {
                        resultStep.data.action = step.data.action;
                    }
                }
            }
            if (step.step_type === models_1.StepType.GHERKIN) {
                if ('keyword' in step.data && resultStep.data != undefined) {
                    resultStep.data.action = step.data.keyword;
                }
            }
            if (step.steps.length > 0) {
                resultStep.steps = await this.transformSteps(step.steps, testTitle);
            }
            resultsSteps.push(resultStep);
        }
        return resultsSteps;
    }
    /**
     * @param {TestStepType[]} steps
     * @param testTitle
     * @returns Promise<TestStepResultCreate[]>
     * @private
     */
    async transformStepsV1(steps, testTitle) {
        const resultsSteps = [];
        for (const step of steps) {
            const attachmentHashes = await this.uploadAttachments(step.attachments);
            const resultStep = {
                status: TestOpsReporter.stepStatusMapV1[step.execution.status],
                attachments: attachmentHashes,
            };
            if (step.step_type === models_1.StepType.TEXT) {
                if ('action' in step.data) {
                    if (step.data.action === '') {
                        this.logEmptyStep(testTitle);
                        resultStep.action = 'Unnamed step';
                    }
                    else {
                        resultStep.action = step.data.action;
                    }
                }
            }
            if (step.step_type === models_1.StepType.GHERKIN) {
                if ('keyword' in step.data) {
                    resultStep.action = step.data.keyword;
                }
            }
            if (step.steps.length > 0) {
                resultStep.steps = await this.transformStepsV1(step.steps, testTitle);
            }
            resultsSteps.push(resultStep);
        }
        return resultsSteps;
    }
    logEmptyStep(testTitle) {
        this.logger.log((0, chalk_1.default) `{magenta Test '${testTitle}' has empty action in step. The reporter will mark this step as unnamed step.}`);
    }
    /**
     * @param {string} title
     * @param {string} description
     * @param {number | undefined} environment
     * @returns {Promise<IdResponse>}
     * @private
     */
    async createRun(title, description, environment) {
        try {
            const runObject = {
                title,
                description,
                is_autotest: true,
                cases: [],
                start_time: this.getDate(),
            };
            if (environment !== undefined) {
                runObject.environment_id = environment;
            }
            if (this.planId) {
                runObject.plan_id = this.planId;
            }
            const { data } = await this.api.runs.createRun(this.projectCode, runObject);
            return data;
        }
        catch (error) {
            throw this.processError(error, 'Error on creating run');
        }
    }
    /**
     * @returns {string}
     * @private
     */
    getDate() {
        const date = new Date();
        date.setSeconds(-10);
        const year = date.getUTCFullYear();
        const month = ('0' + (date.getUTCMonth() + 1).toString()).slice(-2); // Months are zero indexed, so we add 1
        const day = ('0' + date.getUTCDate().toString()).slice(-2);
        const hours = ('0' + date.getUTCHours().toString()).slice(-2);
        const minutes = ('0' + date.getUTCMinutes().toString()).slice(-2);
        const seconds = ('0' + date.getUTCSeconds().toString()).slice(-2);
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }
    /**
     * @returns {Promise<void>}
     * @private
     */
    async uploadAttachments(attachments) {
        if (!this.isUploadAttachments) {
            return [];
        }
        const acc = [];
        for (const attachment of attachments) {
            this.logger.logDebug(`Uploading attachment: ${attachment.file_path ?? attachment.file_name}`);
            try {
                let data;
                if (attachment.file_path) {
                    data = { name: attachment.file_name, value: (0, fs_1.createReadStream)(attachment.file_path) };
                }
                else {
                    if (typeof attachment.content === 'string') {
                        data = { name: attachment.file_name, value: Buffer.from(attachment.content) };
                    }
                    else {
                        data = { name: attachment.file_name, value: attachment.content };
                    }
                }
                const response = await this.api.attachments.uploadAttachment(this.projectCode, [data]);
                if (response.data.result?.[0]?.hash != undefined) {
                    acc.push(response.data.result[0].hash);
                }
            }
            catch (error) {
                this.logger.logError('Cannot upload attachment:', error);
            }
        }
        return acc;
    }
    /**
     * Process error and throw QaseError
     * @param {Error | AxiosError} error
     * @param {string} message
     * @param {object} model
     * @private
     */
    processError(error, message, model) {
        if (!axios_1.default.isAxiosError(error)) {
            return new qase_error_1.QaseError(message, { cause: error });
        }
        if (error.response?.status === 401) {
            return new qase_error_1.QaseError(message + ': \n Unauthorized. Please check your API token. Maybe it is expired or invalid.');
        }
        if (error.response?.status === 404) {
            return new qase_error_1.QaseError(message + ': Not found.');
        }
        if (error.response?.status === 400) {
            return new qase_error_1.QaseError(message + ': Bad request. Body: \n ' + JSON.stringify(model));
        }
        return new qase_error_1.QaseError(message, { cause: error });
    }
    /**
     * @param {string | undefined} url
     * @return string
     * @private
     */
    getBaseUrl(url) {
        if (!url || url === 'qase.io') {
            return 'https://app.qase.io';
        }
        return `https://${url.replace('api', 'app')}`;
    }
    /**
     * @param {number | null} id
     * @param {string} title
     * @return string
     * @private
     */
    prepareFailedTestLink(id, title) {
        const baseLink = `${this.baseUrl}/run/${this.projectCode}/dashboard/${this.run.id}?source=logs&status=%5B2%5D&search=`;
        if (id) {
            return `${baseLink}${id}`;
        }
        return `${baseLink}${encodeURI(title)}`;
    }
    /**
     * Show link to failed test
     * @param {number | null} id
     * @param {string} title
     * @private
     */
    showLink(id, title) {
        const link = this.prepareFailedTestLink(id, title);
        this.logger.log((0, chalk_1.default) `{blue See why this test failed: ${link}}`);
    }
}
exports.TestOpsReporter = TestOpsReporter;
/**
 * @type {Record<TestStatusEnum, string>}
 */
TestOpsReporter.statusMap = {
    [models_1.TestStatusEnum.passed]: 'passed',
    [models_1.TestStatusEnum.failed]: 'failed',
    [models_1.TestStatusEnum.skipped]: 'skipped',
    [models_1.TestStatusEnum.disabled]: 'disabled',
    [models_1.TestStatusEnum.blocked]: 'blocked',
    [models_1.TestStatusEnum.invalid]: 'invalid',
};
/**
 * @type {Record<StepStatusEnum, ResultStepStatus>}
 */
TestOpsReporter.stepStatusMap = {
    [models_1.StepStatusEnum.passed]: qaseio_1.ResultStepStatus.PASSED,
    [models_1.StepStatusEnum.failed]: qaseio_1.ResultStepStatus.FAILED,
    [models_1.StepStatusEnum.blocked]: qaseio_1.ResultStepStatus.BLOCKED,
    [models_1.StepStatusEnum.skipped]: qaseio_1.ResultStepStatus.SKIPPED,
};
/**
 * @type {Record<StepStatusEnum, ResultStepStatus>}
 */
TestOpsReporter.stepStatusMapV1 = {
    [models_1.StepStatusEnum.passed]: qaseio_1.TestStepResultCreateStatusEnum.PASSED,
    [models_1.StepStatusEnum.failed]: qaseio_1.TestStepResultCreateStatusEnum.FAILED,
    [models_1.StepStatusEnum.blocked]: qaseio_1.TestStepResultCreateStatusEnum.BLOCKED,
    [models_1.StepStatusEnum.skipped]: qaseio_1.TestStepResultCreateStatusEnum.BLOCKED,
};
